#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/rmachine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE';
  package App::rmachine;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  use Error::Tiny;
  use Config::Tiny;
  use Time::Crontab;
  use App::rmachine::mirror;
  use App::rmachine::snapshot;
  use App::rmachine::logger;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{config_file} = $params{config_file} || $self->_locate_config_file;
      $self->{log_file} = $params{log_file} || $self->_locate_log_file;
      $self->{quiet} = $params{quiet};
      $self->{test} = $params{test};
      $self->{force} = $params{force};
  
      $self->{logger} = App::rmachine::logger->new(log_file => $self->{log_file}, quiet => $self->{quiet});
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      $self->{logger}->log('rmachine', 'start', 'Starting');
  
      my $config = $self->{config} = $self->_read_config;
  
      my @scenarios = sort grep {/^scenario:/} keys %$config;
      $self->{logger}->log('rmachine', 'scenarios', 'Found ' . scalar(@scenarios) . ' scenario(s)');
  
      my $start_time = time;
  
      foreach my $scenario (@scenarios) {
          my %params = (%{$config->{_} || {}}, %{$config->{$scenario} || {}});
  
          $params{scenario} = $scenario;
          $params{type} ||= 'mirror';
          $params{logger} = $self->{logger};
  
          if (!$self->{force} && $params{period}) {
  	    if (!Time::Crontab->new($params{period})->match($start_time)) {
                  $self->{logger}->log($scenario, 'skip', 'Does not match period');
                  next;
              }
          }
  
          $self->{logger}->log($scenario, 'start');
  
          try {
              $self->_build_action($params{type}, %params)->run;
          
              $self->{logger}->log($scenario, 'end', 'Success');
          } catch {
              my $e = shift;
              $self->{logger}->log($scenario, 'end', "Failure: $e");
          };
      }
  
      $self->{logger}->log('rmachine', 'end', 'Finishing');
  }
  
  sub _read_config {
      my $self = shift;
  
      $self->{logger}->log('rmachine', 'config', 'Reading ' . $self->{config_file});
      my $config = Config::Tiny->read($self->{config_file}, 'encoding(UTF-8)') || die "$Config::Tiny::errstr\n";
  
      my @scenarios = sort grep {/^scenario:/} keys %$config;
  
      my @known_types = qw/mirror snapshot/;
      foreach my $scenario (@scenarios) {
          my %params = (%{$config->{_} || {}}, %{$config->{$scenario} || {}});
  
  	if ($params{period}) {
              try {
  	        Time::Crontab->new($params{period});
              } catch {
                  my $e = shift;
                  die "Error: Wrong period '$params{period}'\n";
              };
          }
  
          if (!grep { $params{type} eq $_ } @known_types) {
              die "Error: Unknown type '$params{type}'\n";
          }
      }
  
      return $config;
  }
  
  sub _locate_config_file {
      my $self = shift;
  
      my @locations = ("$ENV{HOME}/.rmachine/rmachine.conf", "/etc/rmachine/rmachine.conf");
      return $self->_locate_file(\@locations, 'config');
  }
  
  sub _locate_log_file {
      my $self = shift;
  
      my @locations = ("$ENV{HOME}/.rmachine/rmachine.log", "/var/log/rmachine.log");
      return $self->_locate_file(\@locations, 'log');
  }
  
  sub _locate_file {
      my $self = shift;
      my ($locations, $type) = @_;
  
      foreach my $location (@$locations) {
          return $location if -f $location;
      }
  
      die "Can't locate $type file in @$locations\n";
  }
  
  sub _build_action {
      my $self = shift;
      my ($action_name, %params) = @_;
  
      my $action_class = 'App::rmachine::' . $action_name;
  
      return $action_class->new(%params, command_runner => $self->_build_command_runner);
  }
  
  sub _build_command_runner {
      my $self = shift;
  
      return App::rmachine::command_runner->new(quiet => $self->{quiet}, test => $self->{test});
  }
  
  1;
APP_RMACHINE

$fatpacked{"App/rmachine/command/base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_COMMAND_BASE';
  package App::rmachine::command::base;
  
  use strict;
  use warnings;
  
  require Carp;
  use App::rmachine::command_runner;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{command_runner} = $params{command_runner};
  
      Carp::croak('command_runner is required') unless $self->{command_runner};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
      my ($output_cb) = @_;
  
      my $command = $self->_build_command;
      return $self->{command_runner}->run($command, $output_cb);
  }
  
  sub _build_command {
      my $self = shift;
  
      ...
  }
  
  1;
APP_RMACHINE_COMMAND_BASE

$fatpacked{"App/rmachine/command/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_COMMAND_RSYNC';
  package App::rmachine::command::rsync;
  
  use strict;
  use warnings;
  
  use base 'App::rmachine::command::base';
  
  require Carp;
  use App::rmachine::util qw(build_excludes);
  
  sub new {
      my $self = shift->SUPER::new(@_);
      my (%params) = @_;
  
      $self->{source} = $params{source} || Carp::croak('source required');
      $self->{dest} = $params{dest} || Carp::croak('dest required');
  
      $self->{'dry-run'} = $params{'dry-run'};
      $self->{exclude} = $params{exclude};
  
      return $self;
  }
  
  sub _build_command {
      my $self = shift;
  
      my $dry_run = $self->{'dry-run'} ? ' --dry-run' : '';
      my $excludes = build_excludes($self->{exclude});
  
      return 'rsync -rtDH --links --no-p --no-g --no-o --delete --delete-excluded -i --out-format="rmachine: %i %n%L" --chmod=Du+wx ' . $excludes . $dry_run . ' ' . $self->{source} . ' ' . $self->{dest};
  }
  
  1;
APP_RMACHINE_COMMAND_RSYNC

$fatpacked{"App/rmachine/command_runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_COMMAND_RUNNER';
  package App::rmachine::command_runner;
  
  use strict;
  use warnings;
  
  use App::rmachine::exception::failed_exit;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{test} = $params{test};
      $self->{quiet} = $params{quiet};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
      my ($command, $output_cb) = @_;
  
      $output_cb ||= sub {};
  
      print $command, "\n" unless $self->{quiet};
  
      return 0 if $self->{test};
  
      open my $fh, "$command |" or die "Can't fork\n";
  
      while (<$fh>) {
          $output_cb->($_);
          print unless $self->{quiet};
      }
      close $fh;
  
      App::rmachine::exception::failed_exit->throw if $?;
  
      return $?;
  }
  
  1;
APP_RMACHINE_COMMAND_RUNNER

$fatpacked{"App/rmachine/exception/failed_exit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_EXCEPTION_FAILED_EXIT';
  package App::rmachine::exception::failed_exit;
  
  use strict;
  use warnings;
  
  use base 'Error::Tiny::Exception';
  
  1;
APP_RMACHINE_EXCEPTION_FAILED_EXIT

$fatpacked{"App/rmachine/logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_LOGGER';
  package App::rmachine::logger;
  
  use strict;
  use warnings;
  
  use Time::Piece;
  use File::ReadBackwards;
  use App::rmachine::util qw(current_time);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{quiet} = $params{quiet};
      $self->{log_file} = $params{log_file};
  
      return $self;
  }
  
  sub log {
      my $self = shift;
      my ($source, $action, $message) = @_;
  
      $message = '' unless defined $message;
  
      my $log_message = join ' ', current_time(), "[$source]", "[$action]", $message;
      $log_message .= "\n";
  
      open my $fh, '>>:encoding(UTF-8)', $self->{log_file} or die "Can't open log file '$self->{log_file}': $!\n";
      print $fh $log_message;
      close $fh;
  
      print $log_message unless $self->{quiet};
  
      return $self;
  }
  
  sub grep_last {
      my $self = shift;
      my (%params) = @_;
  
      my $bw = File::ReadBackwards->new($self->{log_file}) or die "Can't open log file '$self->{log_file}' $!\n" ;
  
      while( defined( my $log_line = $bw->readline ) ) {
          my ($date, $source, $action, $message) = $log_line =~ m/^([^ ]+) \[(.*?)\] \[(.*?)\] (.*)/;
  
          if (my $needed_source = $params{source}) {
              next unless $source eq $needed_source;
          }
  
          if (my $needed_action = $params{action}) {
              next unless $action eq $needed_action;
          }
  
          return {date => $date, source => $source, action => $action, message => $message};
      }
  
      return;
  }
  
  1;
APP_RMACHINE_LOGGER

$fatpacked{"App/rmachine/mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_MIRROR';
  package App::rmachine::mirror;
  
  use strict;
  use warnings;
  
  use App::rmachine::command::rsync;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{command_runner} = $params{command_runner};
      $self->{logger} = $params{logger};
  
      $self->{source} = $params{source};
      $self->{dest} = $params{dest};
      $self->{exclude} = $params{exclude};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      $self->log('rsync');
      return $self->_build_command(
  	source => $self->{source},
  	dest => $self->{dest},
  	exclude => $self->{exclude},
          command_runner => $self->{command_runner},
      )->run;
  }
  
  sub log {
      my $self = shift;
  
      $self->{logger}->log($self->{scenario}, @_);
  }
  
  sub _build_command {
      my $self = shift;
  
      return App::rmachine::command::rsync->new(@_);
  }
  
  1;
APP_RMACHINE_MIRROR

$fatpacked{"App/rmachine/snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_SNAPSHOT';
  package App::rmachine::snapshot;
  
  use strict;
  use warnings;
  
  use Cwd qw(realpath);
  use App::rmachine::command::rsync;
  use App::rmachine::mirror;
  use App::rmachine::util qw(is_dir_empty current_time);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{scenario} = $params{scenario};
      $self->{command_runner} = $params{command_runner};
  
      $self->{source} = $params{source};
      $self->{dest} = $params{dest};
  
      $self->{quiet} = $params{quiet};
      $self->{exclude} = $params{exclude};
      $self->{logger} = $params{logger};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      my $latest_link = "$self->{dest}/latest";
  
      if (-e $latest_link && !-l $latest_link) {
          die "Error: link '$self->{dest}/latest' is not a symlink\n";
      }
  
      if (!-e $latest_link) {
          if (!is_dir_empty($self->{dest})) {
  	    die "Error: link '$self->{dest}/latest' does not exist, but '$self->{dest}' is not empty\n";
          }
  	else {
              my $new_snapshot = $self->_build_new_snapshot_name();
  
  	    my $mirror = $self->_build_mirror_action(
  		command_runner => $self->{command_runner},
  		source => $self->{source},
  		dest => "$self->{dest}/$new_snapshot/"
  	    );
  	    $mirror->run;
  
              return $self->{command_runner}->run("ln -s '$self->{dest}/$new_snapshot' '$self->{dest}/latest'");
  	}
      }
  
      my $changes = '';
      my $rsync_changes = App::rmachine::command::rsync->new(
          command_runner => $self->{command_runner},
          source => "$self->{source}/",
          'dry-run' => 1,
          dest => "$self->{dest}/latest/",
          exclude => $self->{exclude}
      )->run(sub {
          $changes .= $_ if /rmachine:/;
      });
  
      if ($changes) {
          $self->log('changes', 'Found changes');
  
          my $new_snapshot = $self->_build_new_snapshot_name();
  
  	my $latest_resolved = realpath("$self->{dest}/latest");
          $self->{command_runner}->run("mkdir '$self->{dest}/$new_snapshot'");
          $self->{command_runner}->run("cp -alR $latest_resolved/* $self->{dest}/$new_snapshot");
  
          $self->log('rsync');
          App::rmachine::command::rsync->new(
              command_runner => $self->{command_runner},
              source => "$self->{source}/",
              dest => "$self->{dest}/$new_snapshot/",
              exclude => $self->{exclude}
          )->run;
  
          $self->{command_runner}->run("rm $self->{dest}/latest");
          $self->{command_runner}->run("ln -s $self->{dest}/$new_snapshot $self->{dest}/latest");
      }
      else {
          $self->log('changes', 'No changes');
      }
  
      return;
  }
  
  sub log {
      my $self = shift;
  
      $self->{logger}->log($self->{scenario}, @_);
  }
  
  sub _build_new_snapshot_name {
      my $self = shift;
  
      return current_time();
  }
  
  sub _build_mirror_action {
      my $self = shift;
      
      return App::rmachine::mirror->new(logger => $self->{logger}, @_);
  }
  
  1;
APP_RMACHINE_SNAPSHOT

$fatpacked{"App/rmachine/util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_UTIL';
  package App::rmachine::util;
  
  use strict;
  use warnings;
  
  use base 'Exporter';
  
  our @EXPORT_OK = qw(build_excludes is_dir_empty current_time);
  
  use Time::Piece;
  use Time::HiRes qw(gettimeofday);
  
  sub build_excludes {
  	my $excludes = shift;
  
  	return '' unless $excludes;
  
  	return join ' ', map { "--exclude=$_" } split /,/, $excludes;
  }
  
  sub is_dir_empty {
      my $dirname = shift;
  
      opendir(my $dh, $dirname) or die "Not a directory '$dirname'\n";
      return scalar(grep { $_ ne "." && $_ ne ".." } readdir($dh)) == 0;
  }
  
  sub current_time {
      my $time = Time::Piece->new->strftime('%Y-%m-%dT%T');
      my (undef, $microseconds) = gettimeofday;
      $microseconds =~ s{(\d{4})\d+}{$1};
  
      return $time . '.' . $microseconds . Time::Piece->new->strftime('%z');
  }
  
  1;
APP_RMACHINE_UTIL

$fatpacked{"Config/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_TINY';
  package Config::Tiny;
  
  # If you thought Config::Simple was small...
  
  use strict;
  our $VERSION = '2.20'; # Also change version # in t/02.main.t.
  BEGIN {
  	require 5.008001;
  	$Config::Tiny::errstr  = '';
  }
  
  # Create an empty object
  sub new { bless {}, shift }
  
  # Create an object from a file
  sub read {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $file  = shift or return $class->_error('No file name provided');
  
  	# Slurp in the file.
  
  	my $encoding = shift;
  	$encoding    = $encoding ? "<:$encoding" : '<';
  	local $/     = undef;
  
  	open( CFG, $encoding, $file ) or return $class->_error( "Failed to open file '$file' for reading: $!" );
  	my $contents = <CFG>;
  	close( CFG );
  
  	return $class -> _error("Reading from '$file' returned undef") if (! defined $contents);
  
  	return $class->read_string( $contents );
  }
  
  # Create an object from a string
  sub read_string {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $self  = bless {}, $class;
  	return undef unless defined $_[0];
  
  	# Parse the file
  	my $ns      = '_';
  	my $counter = 0;
  	foreach ( split /(?:\015{1,2}\012|\015|\012)/, shift ) {
  		$counter++;
  
  		# Skip comments and empty lines
  		next if /^\s*(?:\#|\;|$)/;
  
  		# Remove inline comments
  		s/\s\;\s.+$//g;
  
  		# Handle section headers
  		if ( /^\s*\[\s*(.+?)\s*\]\s*$/ ) {
  			# Create the sub-hash if it doesn't exist.
  			# Without this sections without keys will not
  			# appear at all in the completed struct.
  			$self->{$ns = $1} ||= {};
  			next;
  		}
  
  		# Handle properties
  		if ( /^\s*([^=]+?)\s*=\s*(.*?)\s*$/ ) {
  			$self->{$ns}->{$1} = $2;
  			next;
  		}
  
  		return $self->_error( "Syntax error at line $counter: '$_'" );
  	}
  
  	$self;
  }
  
  # Save an object to a file
  sub write {
  	my $self     = shift;
  	my $file     = shift or return $self->_error('No file name provided');
  	my $encoding = shift;
  	$encoding    = $encoding ? ">:$encoding" : '>';
  
  	# Write it to the file
  	my $string = $self->write_string;
  	return undef unless defined $string;
  	open( CFG, $encoding, $file ) or return $self->_error(
  		"Failed to open file '$file' for writing: $!"
  		);
  	print CFG $string;
  	close CFG;
  
  	return 1;
  }
  
  # Save an object to a string
  sub write_string {
  	my $self = shift;
  
  	my $contents = '';
  	foreach my $section ( sort { (($b eq '_') <=> ($a eq '_')) || ($a cmp $b) } keys %$self ) {
  		# Check for several known-bad situations with the section
  		# 1. Leading whitespace
  		# 2. Trailing whitespace
  		# 3. Newlines in section name
  		return $self->_error(
  			"Illegal whitespace in section name '$section'"
  		) if $section =~ /(?:^\s|\n|\s$)/s;
  		my $block = $self->{$section};
  		$contents .= "\n" if length $contents;
  		$contents .= "[$section]\n" unless $section eq '_';
  		foreach my $property ( sort keys %$block ) {
  			return $self->_error(
  				"Illegal newlines in property '$section.$property'"
  			) if $block->{$property} =~ /(?:\012|\015)/s;
  			$contents .= "$property=$block->{$property}\n";
  		}
  	}
  
  	$contents;
  }
  
  # Error handling
  sub errstr { $Config::Tiny::errstr }
  sub _error { $Config::Tiny::errstr = $_[1]; undef }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Config::Tiny - Read/Write .ini style files with as little code as possible
  
  =head1 SYNOPSIS
  
  	# In your configuration file
  	rootproperty=blah
  
  	[section]
  	one=twp
  	three= four
  	Foo =Bar
  	empty=
  
  	# In your program
  	use Config::Tiny;
  
  	# Create a config
  	my $Config = Config::Tiny->new;
  
  	# Open the config
  	$Config = Config::Tiny->read( 'file.conf' );
  	$Config = Config::Tiny->read( 'file.conf', 'utf8' ); # Neither ':' nor '<:' prefix!
  	$Config = Config::Tiny->read( 'file.conf', 'encoding(iso-8859-1)');
  
  	# Reading properties
  	my $rootproperty = $Config->{_}->{rootproperty};
  	my $one = $Config->{section}->{one};
  	my $Foo = $Config->{section}->{Foo};
  
  	# Changing data
  	$Config->{newsection} = { this => 'that' }; # Add a section
  	$Config->{section}->{Foo} = 'Not Bar!';     # Change a value
  	delete $Config->{_};                        # Delete a value or section
  
  	# Save a config
  	$Config->write( 'file.conf' );
  	$Config->write( 'file.conf', 'utf8' ); # Neither ':' nor '>:' prefix!
  
  	# Shortcuts
  	my($rootproperty) = $$Config{_}{rootproperty};
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  	my($config) = Config::Tiny -> read_string("[init]\nalpha=bet");
  	my($value)  = $$config{init}{alpha}; # $value is 'bet'.
  
  =head1 DESCRIPTION
  
  C<Config::Tiny> is a Perl class to read and write .ini style configuration
  files with as little code as possible, reducing load time and memory
  overhead.
  
  Most of the time it is accepted that Perl applications use a lot
  of memory and modules.
  
  The C<*::Tiny> family of modules is specifically intended to provide an ultralight alternative to the
  standard modules.
  
  This module is primarily for reading human written files, and anything we write shouldn't need to have
  documentation/comments. If you need something with more power move up to L<Config::Simple>, L<Config::General>
  or one of the many other C<Config::*> modules.
  
  Lastly, L<Config::Tiny> does B<not> preserve your comments, whitespace, or the order of your config file.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 CONFIGURATION FILE SYNTAX
  
  Files are the same format as for MS Windows C<*.ini> files. For example:
  
  	[section]
  	var1=value1
  	var2=value2
  
  If a property is outside of a section at the beginning of a file, it will
  be assigned to the C<"root section">, available at C<$Config-E<gt>{_}>.
  
  Lines starting with C<'#'> or C<';'> are considered comments and ignored,
  as are blank lines.
  
  When writing back to the config file, all comments, custom whitespace,
  and the ordering of your config file elements is discarded. If you need
  to keep the human elements of a config when writing back, upgrade to
  something better, this module is not for you.
  
  =head1 METHODS
  
  =head2 errstr()
  
  Returns a string representing the most recent error, or the empty string.
  
  You can also retrieve the error message from the C<$Config::Tiny::errstr> variable.
  
  =head2 new()
  
  The constructor C<new> creates and returns an empty C<Config::Tiny> object.
  
  =head2 read($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<read> constructor reads a config file, $filename, and returns a new
  C<Config::Tiny> object containing the properties in the file.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '<' or '<:'.
  
  Returns the object on success, or C<undef> on error.
  
  When C<read> fails, C<Config::Tiny> sets an error message internally
  you can recover via C<Config::Tiny-E<gt>errstr>. Although in B<some>
  cases a failed C<read> will also set the operating system error
  variable C<$!>, not all errors do and you should not rely on using
  the C<$!> variable.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 read_string($string)
  
  The C<read_string> method takes as argument the contents of a config file
  as a string and returns the C<Config::Tiny> object for it.
  
  =head2 write($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<write> method generates the file content for the properties, and
  writes it to disk to the filename specified.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '>' or '>:'.
  
  Returns true on success or C<undef> on error.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 write_string()
  
  Generates the file content for the object and returns it as a string.
  
  =head1 FAQ
  
  =head2 Why can't I put comments at the ends of lines?
  
  Because a line like:
  
  	key=value # A comment
  
  Sets key to 'value # A comment' :-(.
  
  This conforms to the syntax discussed in L</CONFIGURATION FILE SYNTAX>.
  
  =head2 Why can't I omit the '=' signs?
  
  E.g.:
  
  	[Things]
  	my =
  	list =
  	of =
  	things =
  
  Instead of:
  
  	[Things]
  	my
  	list
  	of
  	things
  
  Because the use of '=' signs is a type of mandatory documentation. It indicates that that section contains 4 items,
  and not 1 odd item split over 4 lines.
  
  =head2 Why do I have to assign the result of a method call to a variable?
  
  This question comes from RT#85386.
  
  Yes, the syntax may seem odd, but you don't have to call both new() and read_string().
  
  Try:
  
  	perl -MData::Dumper -MConfig::Tiny -E 'my $c=Config::Tiny->read_string("one=s"); say Dumper $c'
  
  Or:
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  Or even, a bit ridiculously:
  
  	my($value) = ${Config::Tiny -> read_string('alpha=bet')}{_}{alpha}; # $value is 'bet'.
  
  =head1 CAVEATS
  
  =head2 Unsupported Section Headers
  
  Some edge cases in section headers are not supported, and additionally may not
  be detected when writing the config file.
  
  Specifically, section headers with leading whitespace, trailing whitespace,
  or newlines anywhere in the section header, will not be written correctly
  to the file and may cause file corruption.
  
  =head2 Setting an option more than once
  
  C<Config::Tiny> will only recognize the first time an option is set in a
  config file. Any further attempts to set the same option later in the config
  file are ignored.
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Config-Tiny>
  
  For other issues, or commercial enhancement or support, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Maintanence from V 2.15: Ron Savage L<http://savage.net.au/>.
  
  =head1 ACKNOWLEGEMENTS
  
  Thanks to Sherzod Ruzmetov E<lt>sherzodr@cpan.orgE<gt> for
  L<Config::Simple>, which inspired this module by being not quite
  "simple" enough for me :).
  
  =head1 SEE ALSO
  
  See, amongst many: L<Config::Simple> and L<Config::General>.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 COPYRIGHT
  
  Copyright 2002 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
CONFIG_TINY

$fatpacked{"Error/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TINY';
  package Error::Tiny;
  
  use strict;
  use warnings;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  
  our $VERSION = '0.03';
  
  BEGIN {
      require Exporter;
      @ISA = qw(Exporter);
  }
  
  @EXPORT = @EXPORT_OK = qw(try then catch);
  
  require Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  require Scalar::Util;
  
  use Error::Tiny::Exception;
  use Error::Tiny::Catch;
  use Error::Tiny::Then;
  
  sub try(&;@) {
      my ($try, @handlers) = @_;
  
      my $wantarray = wantarray;
  
      my @ret;
      eval { @ret = $wantarray ? $try->() : scalar $try->(); 1 } || do {
          my $e      = $@;
          my $orig_e = $e;
  
          if (!Scalar::Util::blessed($e)) {
              $orig_e =~ s{ at ([\S]+) line (\d+)\.\s*$}{}ms;
              $e = Error::Tiny::Exception->new(
                  message => $orig_e,
                  file    => $1,
                  line    => $2
              );
          }
  
          for my $handler (@handlers) {
              if ($handler && $handler->isa('Error::Tiny::Catch')) {
                  if ($e->isa($handler->class)) {
                      return $handler->handler->($e);
                  }
              }
          }
  
          Carp::croak($orig_e);
      };
  
      return $wantarray ? @ret : $ret[0];
  }
  
  sub catch(&;@) {
      my ($class, $handler) =
        @_ == 2 ? ($_[0], $_[1]->handler) : ('Error::Tiny::Exception', $_[0]);
  
      Error::Tiny::Catch->new(handler => $handler, class => $class);
  }
  
  sub then(&;@) {
      my ($handler, $subhandler) = @_;
  
      (Error::Tiny::Then->new(handler => $handler), $subhandler);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Error::Tiny - Tiny exceptions
  
  =head1 SYNOPSIS
  
      use Error::Tiny;
  
      try {
          dangerous();
      }
      catch MyCustomException then {
          my $e = shift;
  
          ...everything whose parent is MyCustomException...
      }
      catch {
          my $e = shift;
  
          ...everything else goes here...
      };
  
  =head1 DESCRIPTION
  
  L<Error::Tiny> is a lightweight exceptions implementation.
  
  =head1 FEATURES
  
  =head2 C<Objects everywhere>
  
  You will always get an object in the catch block. No need to check if it's
  a blessed reference or anything like that. And there is no need for
  C<$SIG{__DIE__}>!
  
  =head2 C<Exception class built-in>
  
  L<Error::Tiny::Exception> is a lightweight base exception class. It is easy to
  throw an exception:
  
      Error::Tiny::Exception->throw('error');
  
  =head1 WARNING
  
  If you start getting strange behaviour when working with exceptions, make sure
  that you C<use> L<Error::Tiny> in the correct package in the correct place.
  Somehow perl doesn't report this as an error.
  
  This will not work:
  
      use Error::Tiny;
      package MyPackage;
  
      try { ... };
  
  =head1 DEVELOPMENT
  
  =head2 Repository
  
      http://github.com/vti/error-tiny
  
  =head1 AUTHOR
  
  Viacheslav Tykhanovskyi, C<vti@cpan.org>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2013, Viacheslav Tykhanovskyi
  
  This program is free software, you can redistribute it and/or modify it under
  the terms of the Artistic License version 2.0.
  
  =cut
ERROR_TINY

$fatpacked{"Error/Tiny/Catch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TINY_CATCH';
  package Error::Tiny::Catch;
  
  use strict;
  use warnings;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{handler} = $params{handler};
      $self->{class}   = $params{class};
  
      Carp::croak('class is required') unless $self->{class};
  
      return $self;
  }
  
  sub handler { $_[0]->{handler} }
  sub class   { $_[0]->{class} }
  
  1;
ERROR_TINY_CATCH

$fatpacked{"Error/Tiny/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TINY_EXCEPTION';
  package Error::Tiny::Exception;
  
  use strict;
  use warnings;
  
  require Carp;
  
  use overload '""' => \&to_string, fallback => 1;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{message} = $params{message};
      $self->{file}    = $params{file};
      $self->{line}    = $params{line};
  
      return $self;
  }
  
  sub message { $_[0]->{message} }
  sub line    { $_[0]->{line} }
  sub file    { $_[0]->{file} }
  
  sub throw {
      my $class = shift;
      my ($message) = @_;
  
      my (undef, $file, $line) = caller(0);
      my $self = $class->new(message => $message, file => $file, line => $line);
  
      Carp::croak($self);
  }
  
  sub rethrow {
      my $self = shift;
  
      Carp::croak($self);
  }
  
  sub catch {
      my $self = shift;
      my ($then, @tail) = @_;
  
      my $class = ref($self) ? ref($self) : $self;
      (Error::Tiny::Catch->new(handler => $then->handler, class => $class),
          @tail);
  }
  
  sub to_string {
      my $self = shift;
  
      my $message = $self->{message};
      $message =~ s{$}{ at $self->{file} line $self->{line}.}m;
  
      $message;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Error::Tiny::Exception - Base exception
  
  =head1 SYNOPSIS
  
      use Error::Tiny::Exception;
  
      Error::Tiny::Exception->throw('my error');
  
  =head1 DESCRIPTION
  
  L<Error::Tiny::Exception> is a base exception for L<Error::Tiny>.
  
  =head1 METHODS
  
  =head2 C<throw>
  
  Throw exception.
  
  =head2 C<rethrow>
  
  Rethrow exception.
  
  =head2 C<message>
  
  Exception message.
  
  =head2 C<file>
  
  Exception file.
  
  =head2 C<line>
  
  Exception line.
  
  =cut
ERROR_TINY_EXCEPTION

$fatpacked{"Error/Tiny/Then.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TINY_THEN';
  package Error::Tiny::Then;
  
  use strict;
  use warnings;
  
  require Carp;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{handler} = $params{handler};
  
      Carp::croak('handler is required') unless $self->{handler};
  
      return $self;
  }
  
  sub handler { $_[0]->{handler} }
  
  1;
ERROR_TINY_THEN

$fatpacked{"File/ReadBackwards.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_READBACKWARDS';
  # File::ReadBackwards.pm
  
  # Copyright (C) 2003 by Uri Guttman. All rights reserved.
  # mail bugs, comments and feedback to uri@stemsystems.com
  
  package File::ReadBackwards ;
  
  use strict ;
  
  use vars qw( $VERSION ) ;
  
  $VERSION = '1.05' ;
  
  use Symbol ;
  use Fcntl qw( :seek O_RDONLY ) ;
  use Carp ;
  
  my $max_read_size = 1 << 13 ;
  
  my $default_rec_sep ;
  
  BEGIN {
  
  # set the default record separator according to this OS
  # this needs testing and expansion.
  
  # look for CR/LF types
  # then look for CR types
  # else it's a LF type
  
  	if ( $^O =~ /win32/i || $^O =~ /vms/i ) {
  
  		$default_rec_sep = "\015\012" ;
  	}
  	elsif ( $^O =~ /mac/i ) {
  
  		$default_rec_sep = "\015" ;
  	}
  	else {
  		$default_rec_sep = "\012" ;
  	}
  
  # the tied interface is exactly the same as the object one, so all we
  # need to do is to alias the subs with typeglobs
  
  	*TIEHANDLE = \&new ;
  	*READLINE = \&readline ;
   	*EOF = \&eof ;
   	*CLOSE = \&close ;
   	*TELL = \&tell ;
  
  # added getline alias for compatibility with IO::Handle
  
  	*getline = \&readline ;
  }
  
  
  # constructor for File::ReadBackwards
  
  sub new {
  
  	my( $class, $filename, $rec_sep, $sep_is_regex ) = @_ ;
  
  # check that we have a filename
  
  	defined( $filename ) || return ;
  
  # see if this file uses the default of a cr/lf separator
  # those files will get cr/lf converted to \n
  
  	$rec_sep ||= $default_rec_sep ;
  	my $is_crlf = $rec_sep eq "\015\012" ;
  
  # get a handle and open the file
  
  	my $handle = gensym ;
  	sysopen( $handle, $filename, O_RDONLY ) || return ;
  	binmode $handle ;
  
  # seek to the end of the file and get its size
  
  	my $seek_pos = sysseek( $handle, 0, SEEK_END ) or return ;
  
  # get the size of the first block to read,
  # either a trailing partial one (the % size) or full sized one (max read size)
  
  	my $read_size = $seek_pos % $max_read_size || $max_read_size ;
  
  # create the object
  
  	my $self = bless {
  			'file_name'	=> $filename,
  			'handle'	=> $handle,
  			'read_size'	=> $read_size,
  			'seek_pos'	=> $seek_pos,
  			'lines'		=> [],
  			'is_crlf'	=> $is_crlf,
  			'rec_sep'	=> $rec_sep,
  			'sep_is_regex'	=> $sep_is_regex,
  
  		}, $class ;
  
  	return( $self ) ;
  }
  
  # read the previous record from the file
  # 
  sub readline {
  
  	my( $self, $line_ref ) = @_ ;
  
  	my $read_buf ;
  
  # get the buffer of lines
  
  	my $lines_ref = $self->{'lines'} ;
  
  	return unless $lines_ref ;
  
  	while( 1 ) {
  
  # see if there is more than 1 line in the buffer
  
  		if ( @{$lines_ref} > 1 ) {
  
  # we have a complete line so return it
  # and convert those damned cr/lf lines to \n
  
  			$lines_ref->[-1] =~ s/\015\012/\n/
  					if $self->{'is_crlf'} ;
  
  			return( pop @{$lines_ref} ) ;
  		}
  
  # we don't have a complete, so have to read blocks until we do
  
  		my $seek_pos = $self->{'seek_pos'} ;
  
  # see if we are at the beginning of the file
  
  		if ( $seek_pos == 0 ) {
  
  # the last read never made more lines, so return the last line in the buffer
  # if no lines left then undef will be returned
  # and convert those damned cr/lf lines to \n
  
  			$lines_ref->[-1] =~ s/\015\012/\n/
  					if @{$lines_ref} && $self->{'is_crlf'} ;
  
  			return( pop @{$lines_ref} ) ;
  		}
  
  # we have to read more text so get the handle and the current read size
  
  		my $handle = $self->{'handle'} ;
  		my $read_size = $self->{'read_size'} ;
  
  # after the first read, always read the maximum size
  
  		$self->{'read_size'} = $max_read_size ;
  
  # seek to the beginning of this block and save the new seek position
  
  		$seek_pos -= $read_size ;
  		sysseek( $handle, $seek_pos, SEEK_SET ) ;
  		$self->{'seek_pos'} = $seek_pos ;
  
  # read in the next (previous) block of text
  
  		my $read_cnt = sysread( $handle, $read_buf, $read_size ) ;
  
  # prepend the read buffer to the leftover (possibly partial) line
  
  		my $text = $read_buf ;
  		$text .= shift @{$lines_ref} if @{$lines_ref} ;
  
  # split the buffer into a list of lines
  # this may want to be $/ but reading files backwards assumes plain text and
  # newline separators
  
  		@{$lines_ref} = ( $self->{'sep_is_regex'} ) ?
  	 		$text =~ /(.*?$self->{'rec_sep'}|.+)/gs :
  			$text =~ /(.*?\Q$self->{'rec_sep'}\E|.+)/gs ;
  
  #print "Lines \n=>", join( "<=\n=>", @{$lines_ref} ), "<=\n" ;
  
  	}
  }
  
  sub eof {
  
  	my ( $self ) = @_ ;
  
  	my $seek_pos = $self->{'seek_pos'} ;
  	my $lines_count = @{ $self->{'lines'} } ;
  	return( $seek_pos == 0 && $lines_count == 0 ) ;
  }
  
  sub tell {
  	my ( $self ) = @_ ;
  
  	my $seek_pos = $self->{'seek_pos'} ;
  	$seek_pos + length(join "", @{ $self->{'lines'} });
  }
  
  sub get_handle {
  	my ( $self ) = @_ ;
  
  	my $handle = $self->{handle} ;
  	seek( $handle, $self->tell, SEEK_SET ) ;
  	return $handle ;
  }
  
  sub close {
  
  	my ( $self ) = @_ ;
  
  	my $handle = delete( $self->{'handle'} ) ;
  	delete( $self->{'lines'} ) ;
  
  	CORE::close( $handle ) ;
  }
  
  __END__
  
  
  =head1 NAME
  
  File::ReadBackwards.pm -- Read a file backwards by lines.
   
  
  =head1 SYNOPSIS
  
      use File::ReadBackwards ;
  
      # Object interface
  
      $bw = File::ReadBackwards->new( 'log_file' ) or
  			die "can't read 'log_file' $!" ;
  
      while( defined( $log_line = $bw->readline ) ) {
  	    print $log_line ;
      }
  
      # ... or the alternative way of reading
  
      until ( $bw->eof ) {
  	    print $bw->readline ;
      }
  
      # Tied Handle Interface
  
      tie *BW, 'File::ReadBackwards', 'log_file' or
  			die "can't read 'log_file' $!" ;
  
      while( <BW> ) {
  	    print ;
      }
  
  =head1 DESCRIPTION
    
  
  This module reads a file backwards line by line. It is simple to use,
  memory efficient and fast. It supports both an object and a tied handle
  interface.
  
  It is intended for processing log and other similar text files which
  typically have their newest entries appended to them. By default files
  are assumed to be plain text and have a line ending appropriate to the
  OS. But you can set the input record separator string on a per file
  basis.
  
  
  =head1 OBJECT INTERFACE
   
  These are the methods in C<File::ReadBackwards>' object interface:
  
  
  =head2 new( $file, [$rec_sep], [$sep_is_regex] )
  
  C<new> takes as arguments a filename, an optional record separator and
  an optional flag that marks the record separator as a regular
  expression. It either returns the object on a successful open or undef
  upon failure. $! is set to the error code if any.
  
  =head2 readline
  
  C<readline> takes no arguments and it returns the previous line in the
  file or undef when there are no more lines in the file. If the file is
  a non-seekable file (e.g. a pipe), then undef is returned.
  
  =head2 getline
  
  C<getline> is an alias for the readline method. It is here for
  compatibilty with the IO::* classes which has a getline method.
  
  =head2 eof
  
  C<eof> takes no arguments and it returns true when readline() has
  iterated through the whole file.
  
  =head2 close
  
  C<close> takes no arguments and it closes the handle
  
  =head2 tell
  
  C<tell> takes no arguments and it returns the current filehandle position.
  This value may be used to seek() back to this position using a normal
  file handle.
  
  =head2 get_handle
  
  C<get_handle> takes no arguments and it returns the internal Perl
  filehandle used by the File::ReadBackwards object.  This handle may be
  used to read the file forward. Its seek position will be set to the
  position that is returned by the tell() method.  Note that
  interleaving forward and reverse reads may produce unpredictable
  results.  The only use supported at present is to read a file backward
  to a certain point, then use 'handle' to extract the handle, and read
  forward from that point.
  
  =head1 TIED HANDLE INTERFACE
  
  =head2 tie( *HANDLE, 'File::ReadBackwards', $file, [$rec_sep], [$sep_is_regex] )
   
  
  The TIEHANDLE, READLINE, EOF, CLOSE and TELL methods are aliased to
  the new, readline, eof, close and tell methods respectively so refer
  to them for their arguments and API.  Once you have tied a handle to
  File::ReadBackwards the only I/O operation permissible is <> which
  will read the previous line. You can call eof() and close() on the
  tied handle as well. All other tied handle operations will generate an
  unknown method error. Do not seek, write or perform any other
  unsupported operations on the tied handle.
  
  =head1 LINE AND RECORD ENDINGS
   
  
  Since this module needs to use low level I/O for efficiency, it can't
  portably seek and do block I/O without managing line ending conversions.
  This module supports the default record separators of normal line ending
  strings used by the OS. You can also set the separator on a per file
  basis.
  
  The record separator is a regular expression by default, which differs
  from the behavior of $/.
  
  Only if the record separator is B<not> specified and it defaults to
  CR/LF (e.g, VMS, redmondware) will it will be converted to a single
  newline. Unix and MacOS files systems use only a single character for
  line endings and the lines are left unchanged.  This means that for
  native text files, you should be able to process their lines backwards
  without any problems with line endings. If you specify a record
  separator, no conversions will be done and you will get the records as
  if you read them in binary mode.
  
  =head1 DESIGN
  
  It works by reading a large (8kb) block of data from the end of the
  file.  It then splits them on the record separator and stores a list of
  records in the object. Each call to readline returns the top record of
  the list and if the list is empty it refills it by reading the previous
  block from the file and splitting it.  When the beginning of the file is
  reached and there are no more lines, undef is returned.  All boundary
  conditions are handled correctly i.e. if there is a trailing partial
  line (no newline) it will be the first line returned and lines larger
  than the read buffer size are handled properly.
  
  
  =head1 NOTES
   
  
  There is no support for list context in either the object or tied
  interfaces. If you want to slurp all of the lines into an array in
  backwards order (and you don't care about memory usage) just do:
  
  	@back_lines = reverse <FH>.
  
  This module is only intended to read one line at a time from the end of
  a file to the beginning.
  
  =head1 AUTHOR
   
  
  Uri Guttman, uri@stemsystems.com
  
  =head1 COPYRIGHT
   
  
  Copyright (C) 2003 by Uri Guttman. All rights reserved.  This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
FILE_READBACKWARDS

$fatpacked{"Set/Crontab.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SET_CRONTAB';
  # Copyright 2001 Abhijit Menon-Sen <ams@toroid.org>
  
  package Set::Crontab;
  
  use strict;
  use Carp;
  use vars qw( $VERSION );
  
  $VERSION = '1.03';
  
  sub _expand
  {
      my (@list, @and, @not);
      my ($self, $spec, $range) = @_;
  
      # 1,2-4,*/3,!13,>9,<15
      foreach (split /,/, $spec) {
          my @pick;
          my $step = $1 if s#/(\d+)$##;
  
          # 0+"01" == 1
          if    (/^(\d+)$/)       { push @pick, 0+$1;          }
          elsif (/^\*$/)          { push @pick, @$range;       }
          elsif (/^(\d+)-(\d+)$/) { push @pick, 0+$1..0+$2;    } 
          elsif (/^!(\d+)$/)      { push @not,  "\$_ != 0+$1"; }
          elsif (/^([<>])(\d+)$/) { push @and,  "\$_ $1 0+$2"; }
  
          if ($step) {
              my $i;
              @pick = grep { defined $_ if $i++ % $step == 0 } @pick;
          }
  
          push @list, @pick;
      }
  
      if (@and) {
          my $and = join q{ && }, @and;
          push @list, grep { defined $_ if eval $and } @$range;
      }
  
      if (@not) {
          my $not = join q{ && }, @not;
          @list = grep { defined $_ if eval $not } (@list ? @list : @$range);
      }
  
      @list = sort { $a <=> $b } @list;
      return \@list;
  }
  
  sub _initialise
  {
      my ($self, $spec, $range) = @_;
      return undef unless ref($self);
  
      croak "Usage: ".__PACKAGE__."->new(\$spec, [\@range])"
          unless defined $spec && ref($range) eq "ARRAY";
  
      $self->{LIST} = $self->_expand($spec, $range);
      $self->{HASH} = {map {$_ => 1} @{$self->{LIST}}};
  
      return $self;
  };
  
  sub new
  {
      my $class = shift;
      my $self  = bless {}, ref($class) || $class;
      return $self->_initialise(@_);
  }
  
  sub contains
  {
      my ($self, $num) = @_;
  
      croak "Usage: \$set->contains(\$num)" unless ref($self) && defined $num;
      return exists $self->{HASH}{$num};
  }
  
  sub list
  {
      my $self = shift;
  
      croak "Usage: \$set->list()" unless ref($self);
      return @{$self->{LIST}};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Set::Crontab - Expand crontab(5)-style integer lists
  
  =head1 SYNOPSIS
  
  $s = Set::Crontab->new("1-9/3,>15,>30,!23", [0..30]);
  
  if ($s->contains(3)) { ... }
  
  =head1 DESCRIPTION
  
  Set::Crontab parses crontab-style lists of integers and defines some
  utility functions to make it easier to deal with them.
  
  =head2 Syntax
  
  Numbers, ranges, *, and step values all work exactly as described in
  L<crontab(5)>. A few extensions to the standard syntax are described
  below.
  
  =over 4
  
  =item < and >
  
  <N selects the elements smaller than N from the entire range, and adds
  them to the set. >N does likewise for elements larger than N.
  
  =item !
  
  !N excludes N from the set. It applies to the other specified 
  range; otherwise it applies to the specified ranges (i.e. "!3" with a
  range of "1-10" corresponds to "1-2,4-10", but ">3,!7" in the same range
  means "4-6,8-10").
  
  =back
  
  =head2 Functions
  
  =over 4
  
  =item new($spec, [@range])
  
  Creates a new Set::Crontab object and returns a reference to it.
  
  =item contains($num)
  
  Returns true if C<$num> exists in the set.
  
  =item list()
  
  Returns the expanded list corresponding to the set. Elements are in
  ascending order.
  
  =back
  
  The functions described above croak if they are called with incorrect
  arguments.
  
  =head1 SEE ALSO
  
  L<crontab(5)>
  
  =head1 AUTHOR
  
  Abhijit Menon-Sen <ams@toroid.org>
  
  Copyright 2001 Abhijit Menon-Sen <ams@toroid.org>
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
SET_CRONTAB

$fatpacked{"Time/Crontab.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIME_CRONTAB';
  package Time::Crontab;
  
  use 5.008005;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use List::MoreUtils qw/all any uniq/;
  use Set::Crontab;
  
  our $VERSION = "0.02";
  
  my @keys = qw/minute hour day month day_of_week/;
  my @ranges = (
      [0..59], #minute
      [0..23], #hour
      [1..31], #day
      [1..12], #month
      [0..7], #day of week
  );
  my %month_strs = (
      jan => 1,
      feb => 2,
      mar => 3,
      apr => 4,
      may => 5,
      jun => 6,
      jul => 7,
      aug => 8,
      sep => 9,
      oct => 10,
      nov => 11,
      dec => 12,
  );
  my %dow_strs = (
      sun => 0,
      mon => 1,
      tue => 2,
      wed => 3,
      thu => 4,
      fri => 5,
      sat => 6,
  );
  
  sub includes {
      my ($list,$include) = @_;
      my %include = map {
          $_ => 1
      } @$include;
      all { exists $include{$_} } @$list;
  }
  
  sub new {
      my ($class,$str) = @_;
      my $self = bless {}, $class;
      $self->_compile($str);
      $self;
  }
  
  sub _compile {
      my ($self, $str) = @_;
  
      $str =~ s/^\s+//g;
      $str =~ s/\s+$//g;
      my @rules = split /\s+/, $str;
      croak 'incorrect cron field:'.$str if @rules != 5;
      my %rules;
      my $i=0;
      for my $rule_o ( @rules ) {
          my $rule = $rule_o;
          my $key = $keys[$i];
          my $range = $ranges[$i];
          if ( $key eq 'month' ) {
              my $replace = sub {
                  my $month = lc(shift);
                  exists $month_strs{$month} ? $month_strs{$month} : $month;
              };
              $rule =~ s!^([a-z]{3})$!$replace->($1);!ie;
          }
          if ( $key eq 'day_of_week' ) {
              my $replace = sub {
                  my $dow = lc(shift);
                  exists $dow_strs{$dow} ? $dow_strs{$dow} : $dow;
              };
              $rule =~ s!^([a-z]{3})$!$replace->($1)!ie;
          }
          my $set_crontab = Set::Crontab->new($rule, $range);
          my @expand = $set_crontab->list();
          croak "bad format $key: $rule_o($rule)" unless @expand;
          croak "bad range $key: $rule_o($rule)" unless includes(\@expand, $range);
          if ( $key eq 'day_of_week' ) {
              #day of week
              if ( any { $_ == 7 } @expand ) {
                  unshift @expand, 0;
              }
              @expand = uniq @expand;
          }
          $rules{$key} = \@expand;
          $i++;
      }
  
      $self->{rules} = \%rules;
  }
  
  sub _contains {
      my ($self, $key, $num) = @_;
      any { $_ == $num  } @{$self->{rules}->{$key}};
  }
  
  sub match {
      my $self = shift;
      my @lt = localtime($_[0]);
      if ( $self->_contains('minute', $lt[1]) 
        && $self->_contains('hour', $lt[2])
        && ( $self->_contains('day', $lt[3]) || $self->_contains('day_of_week', $lt[6]) )
        && $self->_contains('month', $lt[4]+1) ) {
          return 1;
      }
      return;
  }
  
  sub dump {
      shift->{rules};
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Time::Crontab - parser for crontab date and time field
  
  =head1 SYNOPSIS
  
      use Time::Crontab;
  
      my $time_cron = Time::Crontab->new('0 0 1 * *');
      if ( $time_cron->match(time()) ) {
          do_cron_job();
      }
  
  =head1 DESCRIPTION
  
  Time::Crontab is a parser for crontab date and time field. And 
  it provides simple matcher.
  
  =head1 METHOD
  
  =over 4
  
  =item new($crontab:Str)
  
  Returns Time::Crontab object. If incorrect crontab string was given, Time::Crontab dies.
  
  =item match($unix_timestamp:Num)
  
  Returns whether or not the given unix timestamp matches the crontab
  Timestamps are truncated to minute resolution.
  
  =back
  
  =head1 SUPPORTED SPECS
  
    Field name   Allowed values  Allowed special characters
    Minutes      0-59            * / , -
    Hours        0-23            * / , -
    Day of month 1-31            * / , -
    Month        1-12 or JAN-DEC * / , -
    Day of week  0-6 or SUN-SAT  * / , -
  
  Predefined scheduling definitions are not supported. 
  In month and day_of_week fields, Able to use the first three letters of day or month. But 
  does not support range or list of the names.
  
  =head1 RELATED MODULES
  
  =over 4
  
  =item L<DateTime::Event::Cron>
  
  DateTime::Event::Cron that depends on DateTime. 
  Time::Crontab does not require DateTime or Time::Piece.
  
  =item L<Algorithm::Cron>
  
  Algorithm::Cron also does not require DateTime. 
  It's provides `next_time` method, Time::Crontab provides `match` method.
  
  =back
  
  =head1 LICENSE
  
  Copyright (C) Masahiro Nagano.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Masahiro Nagano E<lt>kazeburo@gmail.comE<gt>
  
  =cut
  
TIME_CRONTAB

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use Fcntl ':flock';
use Getopt::Long;
use App::rmachine;

open my $lock, '<', __FILE__ or die "Can't lock myself\n";
flock $lock, LOCK_EX|LOCK_NB or do { warn "Already running\n"; exit 255 };

my $test = 0;
my $force = 0;
my $quiet = 0;
my $config_file = '';
my $log_file = '';
my $version = '';
GetOptions(
    'test' => \$test,
    'force' => \$force,
    'quiet' => \$quiet,
    'config=s' => \$config_file,
    'log=s' => \$log_file,
    'version' => \$version,
) or die("Error in command line arguments\n");

if ($version) {
    print 'rmachine: ' . $App::rmachine::VERSION, "\n";
    exit 0;
}

App::rmachine->new(config_file => $config_file, log_file => $log_file, quiet => $quiet, test => $test, force => $force)->run(@ARGV);
