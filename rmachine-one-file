#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/rmachine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE';
  package App::rmachine;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  use Error::Tiny;
  use Config::Tiny;
  use Time::Crontab;
  use App::rmachine::mirror;
  use App::rmachine::snapshot;
  use App::rmachine::logger;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{config_file} = $params{config_file} || $self->_locate_config_file;
      $self->{log_file} = $params{log_file} || $self->_locate_log_file;
      $self->{quiet} = $params{quiet};
      $self->{test} = $params{test};
      $self->{force} = $params{force};
  
      $self->{logger} = App::rmachine::logger->new(log_file => $self->{log_file}, quiet => $self->{quiet});
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      $self->{logger}->log('rmachine', 'start', 'Starting');
  
      my $config = $self->{config} = $self->_read_config;
  
      my @scenarios = sort grep {/^scenario:/} keys %$config;
      $self->{logger}->log('rmachine', 'scenarios', 'Found ' . scalar(@scenarios) . ' scenario(s)');
  
      my $start_time = time;
  
      foreach my $scenario (@scenarios) {
          my %params = (%{$config->{_} || {}}, %{$config->{$scenario} || {}});
  
          $params{scenario} = $scenario;
          $params{type} ||= 'mirror';
          $params{logger} = $self->{logger};
  
          if (!$self->{force} && $params{period}) {
  	    if (!Time::Crontab->new($params{period})->match($start_time)) {
                  $self->{logger}->log($scenario, 'skip', 'Does not match period');
                  next;
              }
          }
  
          $self->{logger}->log($scenario, 'start');
  
          try {
              $self->_build_action($params{type}, %params)->run;
          
              $self->{logger}->log($scenario, 'end', 'Success');
          } catch {
              my $e = shift;
              $self->{logger}->log($scenario, 'end', "Failure: $e");
          };
      }
  
      $self->{logger}->log('rmachine', 'end', 'Finishing');
  }
  
  sub _read_config {
      my $self = shift;
  
      $self->{logger}->log('rmachine', 'config', 'Reading ' . $self->{config_file});
      my $config = Config::Tiny->read($self->{config_file}, 'encoding(UTF-8)') || die "$Config::Tiny::errstr\n";
  
      my @scenarios = sort grep {/^scenario:/} keys %$config;
  
      my @known_types = qw/mirror snapshot/;
      foreach my $scenario (@scenarios) {
          my %params = (%{$config->{_} || {}}, %{$config->{$scenario} || {}});
  
  	if ($params{period}) {
              try {
  	        Time::Crontab->new($params{period});
              } catch {
                  my $e = shift;
                  die "Error: Wrong period '$params{period}'\n";
              };
          }
  
          if (!grep { $params{type} eq $_ } @known_types) {
              die "Error: Unknown type '$params{type}'\n";
          }
      }
  
      return $config;
  }
  
  sub _locate_config_file {
      my $self = shift;
  
      my @locations = ("$ENV{HOME}/.rmachine/rmachine.conf", "/etc/rmachine/rmachine.conf");
      return $self->_locate_file(\@locations, 'config');
  }
  
  sub _locate_log_file {
      my $self = shift;
  
      my @locations = ("$ENV{HOME}/.rmachine/rmachine.log", "/var/log/rmachine.log");
      return $self->_locate_file(\@locations, 'log');
  }
  
  sub _locate_file {
      my $self = shift;
      my ($locations, $type) = @_;
  
      foreach my $location (@$locations) {
          return $location if -f $location;
      }
  
      die "Can't locate $type file in @$locations\n";
  }
  
  sub _build_action {
      my $self = shift;
      my ($action_name, %params) = @_;
  
      my $action_class = 'App::rmachine::' . $action_name;
  
      return $action_class->new(%params, command_runner => $self->_build_command_runner);
  }
  
  sub _build_command_runner {
      my $self = shift;
  
      return App::rmachine::command_runner->new(quiet => $self->{quiet}, test => $self->{test});
  }
  
  1;
APP_RMACHINE

$fatpacked{"App/rmachine/command/base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_COMMAND_BASE';
  package App::rmachine::command::base;
  
  use strict;
  use warnings;
  
  require Carp;
  use App::rmachine::command_runner;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{command_runner} = $params{command_runner};
  
      Carp::croak('command_runner is required') unless $self->{command_runner};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
      my ($output_cb) = @_;
  
      my $command = $self->_build_command;
      return $self->{command_runner}->run($command, $output_cb);
  }
  
  sub _build_command {
      my $self = shift;
  
      ...
  }
  
  1;
APP_RMACHINE_COMMAND_BASE

$fatpacked{"App/rmachine/command/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_COMMAND_RSYNC';
  package App::rmachine::command::rsync;
  
  use strict;
  use warnings;
  
  use base 'App::rmachine::command::base';
  
  require Carp;
  use App::rmachine::util qw(build_excludes);
  
  sub new {
      my $self = shift->SUPER::new(@_);
      my (%params) = @_;
  
      $self->{source} = $params{source} || Carp::croak('source required');
      $self->{dest} = $params{dest} || Carp::croak('dest required');
  
      $self->{'dry-run'} = $params{'dry-run'};
      $self->{exclude} = $params{exclude};
  
      return $self;
  }
  
  sub _build_command {
      my $self = shift;
  
      my $dry_run = $self->{'dry-run'} ? ' --dry-run' : '';
      my $excludes = build_excludes($self->{exclude});
  
      return 'rsync -rtDH --links --no-p --no-g --no-o --delete --delete-excluded -i --out-format="rmachine: %i %n%L" --chmod=Du+wx ' . $excludes . $dry_run . ' ' . $self->{source} . ' ' . $self->{dest};
  }
  
  1;
APP_RMACHINE_COMMAND_RSYNC

$fatpacked{"App/rmachine/command_runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_COMMAND_RUNNER';
  package App::rmachine::command_runner;
  
  use strict;
  use warnings;
  
  use App::rmachine::exception::failed_exit;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{test} = $params{test};
      $self->{quiet} = $params{quiet};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
      my ($command, $output_cb) = @_;
  
      $output_cb ||= sub {};
  
      print $command, "\n" unless $self->{quiet};
  
      return 0 if $self->{test};
  
      open my $fh, "$command |" or die "Can't fork\n";
  
      while (<$fh>) {
          $output_cb->($_);
          print unless $self->{quiet};
      }
      close $fh;
  
      App::rmachine::exception::failed_exit->throw if $?;
  
      return $?;
  }
  
  1;
APP_RMACHINE_COMMAND_RUNNER

$fatpacked{"App/rmachine/exception/failed_exit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_EXCEPTION_FAILED_EXIT';
  package App::rmachine::exception::failed_exit;
  
  use strict;
  use warnings;
  
  use base 'Error::Tiny::Exception';
  
  1;
APP_RMACHINE_EXCEPTION_FAILED_EXIT

$fatpacked{"App/rmachine/logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_LOGGER';
  package App::rmachine::logger;
  
  use strict;
  use warnings;
  
  use Time::Piece;
  use File::ReadBackwards;
  use App::rmachine::util qw(current_time);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{quiet} = $params{quiet};
      $self->{log_file} = $params{log_file};
  
      return $self;
  }
  
  sub log {
      my $self = shift;
      my ($source, $action, $message) = @_;
  
      $message = '' unless defined $message;
  
      my $log_message = join ' ', current_time(), "[$source]", "[$action]", $message;
      $log_message .= "\n";
  
      open my $fh, '>>:encoding(UTF-8)', $self->{log_file} or die "Can't open log file '$self->{log_file}': $!\n";
      print $fh $log_message;
      close $fh;
  
      print $log_message unless $self->{quiet};
  
      return $self;
  }
  
  sub grep_last {
      my $self = shift;
      my (%params) = @_;
  
      my $bw = File::ReadBackwards->new($self->{log_file}) or die "Can't open log file '$self->{log_file}' $!\n" ;
  
      while( defined( my $log_line = $bw->readline ) ) {
          my ($date, $source, $action, $message) = $log_line =~ m/^([^ ]+) \[(.*?)\] \[(.*?)\] (.*)/;
  
          if (my $needed_source = $params{source}) {
              next unless $source eq $needed_source;
          }
  
          if (my $needed_action = $params{action}) {
              next unless $action eq $needed_action;
          }
  
          return {date => $date, source => $source, action => $action, message => $message};
      }
  
      return;
  }
  
  1;
APP_RMACHINE_LOGGER

$fatpacked{"App/rmachine/mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_MIRROR';
  package App::rmachine::mirror;
  
  use strict;
  use warnings;
  
  use App::rmachine::command::rsync;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{command_runner} = $params{command_runner};
      $self->{logger} = $params{logger};
  
      $self->{source} = $params{source};
      $self->{dest} = $params{dest};
      $self->{exclude} = $params{exclude};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      $self->log('rsync');
      return $self->_build_command(
  	source => $self->{source},
  	dest => $self->{dest},
  	exclude => $self->{exclude},
          command_runner => $self->{command_runner},
      )->run;
  }
  
  sub log {
      my $self = shift;
  
      $self->{logger}->log($self->{scenario}, @_);
  }
  
  sub _build_command {
      my $self = shift;
  
      return App::rmachine::command::rsync->new(@_);
  }
  
  1;
APP_RMACHINE_MIRROR

$fatpacked{"App/rmachine/snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_SNAPSHOT';
  package App::rmachine::snapshot;
  
  use strict;
  use warnings;
  
  use Cwd qw(realpath);
  use App::rmachine::command::rsync;
  use App::rmachine::mirror;
  use App::rmachine::util qw(is_dir_empty current_time);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{scenario} = $params{scenario};
      $self->{command_runner} = $params{command_runner};
  
      $self->{source} = $params{source};
      $self->{dest} = $params{dest};
  
      $self->{quiet} = $params{quiet};
      $self->{exclude} = $params{exclude};
      $self->{logger} = $params{logger};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      my $latest_link = "$self->{dest}/latest";
  
      if (-e $latest_link && !-l $latest_link) {
          die "Error: link '$self->{dest}/latest' is not a symlink\n";
      }
  
      if (!-e $latest_link) {
          if (!is_dir_empty($self->{dest})) {
  	    die "Error: link '$self->{dest}/latest' does not exist, but '$self->{dest}' is not empty\n";
          }
  	else {
              my $new_snapshot = $self->_build_new_snapshot_name();
  
  	    my $mirror = $self->_build_mirror_action(
  		command_runner => $self->{command_runner},
  		source => $self->{source},
  		dest => "$self->{dest}/$new_snapshot/"
  	    );
  	    $mirror->run;
  
              return $self->{command_runner}->run("ln -s '$self->{dest}/$new_snapshot' '$self->{dest}/latest'");
  	}
      }
  
      my $changes = '';
      my $rsync_changes = App::rmachine::command::rsync->new(
          command_runner => $self->{command_runner},
          source => "$self->{source}/",
          'dry-run' => 1,
          dest => "$self->{dest}/latest/",
          exclude => $self->{exclude}
      )->run(sub {
          $changes .= $_ if /rmachine:/;
      });
  
      if ($changes) {
          $self->log('changes', 'Found changes');
  
          my $new_snapshot = $self->_build_new_snapshot_name();
  
  	my $latest_resolved = realpath("$self->{dest}/latest");
          $self->{command_runner}->run("mkdir '$self->{dest}/$new_snapshot'");
          $self->{command_runner}->run("cp -alR $latest_resolved/* $self->{dest}/$new_snapshot");
  
          $self->log('rsync');
          App::rmachine::command::rsync->new(
              command_runner => $self->{command_runner},
              source => "$self->{source}/",
              dest => "$self->{dest}/$new_snapshot/",
              exclude => $self->{exclude}
          )->run;
  
          $self->{command_runner}->run("rm $self->{dest}/latest");
          $self->{command_runner}->run("ln -s $self->{dest}/$new_snapshot $self->{dest}/latest");
      }
      else {
          $self->log('changes', 'No changes');
      }
  
      return;
  }
  
  sub log {
      my $self = shift;
  
      $self->{logger}->log($self->{scenario}, @_);
  }
  
  sub _build_new_snapshot_name {
      my $self = shift;
  
      return current_time();
  }
  
  sub _build_mirror_action {
      my $self = shift;
      
      return App::rmachine::mirror->new(logger => $self->{logger}, @_);
  }
  
  1;
APP_RMACHINE_SNAPSHOT

$fatpacked{"App/rmachine/util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_RMACHINE_UTIL';
  package App::rmachine::util;
  
  use strict;
  use warnings;
  
  use base 'Exporter';
  
  our @EXPORT_OK = qw(build_excludes is_dir_empty current_time);
  
  use Time::Piece;
  use Time::HiRes qw(gettimeofday);
  
  sub build_excludes {
  	my $excludes = shift;
  
  	return '' unless $excludes;
  
  	return join ' ', map { "--exclude=$_" } split /,/, $excludes;
  }
  
  sub is_dir_empty {
      my $dirname = shift;
  
      opendir(my $dh, $dirname) or die "Not a directory '$dirname'\n";
      return scalar(grep { $_ ne "." && $_ ne ".." } readdir($dh)) == 0;
  }
  
  sub current_time {
      my $time = Time::Piece->new->strftime('%Y-%m-%dT%T');
      my (undef, $microseconds) = gettimeofday;
      $microseconds =~ s{(\d{4})\d+}{$1};
  
      return $time . '.' . $microseconds . Time::Piece->new->strftime('%z');
  }
  
  1;
APP_RMACHINE_UTIL

$fatpacked{"Config/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_TINY';
  package Config::Tiny;
  
  # If you thought Config::Simple was small...
  
  use strict;
  our $VERSION = '2.20'; # Also change version # in t/02.main.t.
  BEGIN {
  	require 5.008001;
  	$Config::Tiny::errstr  = '';
  }
  
  # Create an empty object
  sub new { bless {}, shift }
  
  # Create an object from a file
  sub read {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $file  = shift or return $class->_error('No file name provided');
  
  	# Slurp in the file.
  
  	my $encoding = shift;
  	$encoding    = $encoding ? "<:$encoding" : '<';
  	local $/     = undef;
  
  	open( CFG, $encoding, $file ) or return $class->_error( "Failed to open file '$file' for reading: $!" );
  	my $contents = <CFG>;
  	close( CFG );
  
  	return $class -> _error("Reading from '$file' returned undef") if (! defined $contents);
  
  	return $class->read_string( $contents );
  }
  
  # Create an object from a string
  sub read_string {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $self  = bless {}, $class;
  	return undef unless defined $_[0];
  
  	# Parse the file
  	my $ns      = '_';
  	my $counter = 0;
  	foreach ( split /(?:\015{1,2}\012|\015|\012)/, shift ) {
  		$counter++;
  
  		# Skip comments and empty lines
  		next if /^\s*(?:\#|\;|$)/;
  
  		# Remove inline comments
  		s/\s\;\s.+$//g;
  
  		# Handle section headers
  		if ( /^\s*\[\s*(.+?)\s*\]\s*$/ ) {
  			# Create the sub-hash if it doesn't exist.
  			# Without this sections without keys will not
  			# appear at all in the completed struct.
  			$self->{$ns = $1} ||= {};
  			next;
  		}
  
  		# Handle properties
  		if ( /^\s*([^=]+?)\s*=\s*(.*?)\s*$/ ) {
  			$self->{$ns}->{$1} = $2;
  			next;
  		}
  
  		return $self->_error( "Syntax error at line $counter: '$_'" );
  	}
  
  	$self;
  }
  
  # Save an object to a file
  sub write {
  	my $self     = shift;
  	my $file     = shift or return $self->_error('No file name provided');
  	my $encoding = shift;
  	$encoding    = $encoding ? ">:$encoding" : '>';
  
  	# Write it to the file
  	my $string = $self->write_string;
  	return undef unless defined $string;
  	open( CFG, $encoding, $file ) or return $self->_error(
  		"Failed to open file '$file' for writing: $!"
  		);
  	print CFG $string;
  	close CFG;
  
  	return 1;
  }
  
  # Save an object to a string
  sub write_string {
  	my $self = shift;
  
  	my $contents = '';
  	foreach my $section ( sort { (($b eq '_') <=> ($a eq '_')) || ($a cmp $b) } keys %$self ) {
  		# Check for several known-bad situations with the section
  		# 1. Leading whitespace
  		# 2. Trailing whitespace
  		# 3. Newlines in section name
  		return $self->_error(
  			"Illegal whitespace in section name '$section'"
  		) if $section =~ /(?:^\s|\n|\s$)/s;
  		my $block = $self->{$section};
  		$contents .= "\n" if length $contents;
  		$contents .= "[$section]\n" unless $section eq '_';
  		foreach my $property ( sort keys %$block ) {
  			return $self->_error(
  				"Illegal newlines in property '$section.$property'"
  			) if $block->{$property} =~ /(?:\012|\015)/s;
  			$contents .= "$property=$block->{$property}\n";
  		}
  	}
  
  	$contents;
  }
  
  # Error handling
  sub errstr { $Config::Tiny::errstr }
  sub _error { $Config::Tiny::errstr = $_[1]; undef }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Config::Tiny - Read/Write .ini style files with as little code as possible
  
  =head1 SYNOPSIS
  
  	# In your configuration file
  	rootproperty=blah
  
  	[section]
  	one=twp
  	three= four
  	Foo =Bar
  	empty=
  
  	# In your program
  	use Config::Tiny;
  
  	# Create a config
  	my $Config = Config::Tiny->new;
  
  	# Open the config
  	$Config = Config::Tiny->read( 'file.conf' );
  	$Config = Config::Tiny->read( 'file.conf', 'utf8' ); # Neither ':' nor '<:' prefix!
  	$Config = Config::Tiny->read( 'file.conf', 'encoding(iso-8859-1)');
  
  	# Reading properties
  	my $rootproperty = $Config->{_}->{rootproperty};
  	my $one = $Config->{section}->{one};
  	my $Foo = $Config->{section}->{Foo};
  
  	# Changing data
  	$Config->{newsection} = { this => 'that' }; # Add a section
  	$Config->{section}->{Foo} = 'Not Bar!';     # Change a value
  	delete $Config->{_};                        # Delete a value or section
  
  	# Save a config
  	$Config->write( 'file.conf' );
  	$Config->write( 'file.conf', 'utf8' ); # Neither ':' nor '>:' prefix!
  
  	# Shortcuts
  	my($rootproperty) = $$Config{_}{rootproperty};
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  	my($config) = Config::Tiny -> read_string("[init]\nalpha=bet");
  	my($value)  = $$config{init}{alpha}; # $value is 'bet'.
  
  =head1 DESCRIPTION
  
  C<Config::Tiny> is a Perl class to read and write .ini style configuration
  files with as little code as possible, reducing load time and memory
  overhead.
  
  Most of the time it is accepted that Perl applications use a lot
  of memory and modules.
  
  The C<*::Tiny> family of modules is specifically intended to provide an ultralight alternative to the
  standard modules.
  
  This module is primarily for reading human written files, and anything we write shouldn't need to have
  documentation/comments. If you need something with more power move up to L<Config::Simple>, L<Config::General>
  or one of the many other C<Config::*> modules.
  
  Lastly, L<Config::Tiny> does B<not> preserve your comments, whitespace, or the order of your config file.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 CONFIGURATION FILE SYNTAX
  
  Files are the same format as for MS Windows C<*.ini> files. For example:
  
  	[section]
  	var1=value1
  	var2=value2
  
  If a property is outside of a section at the beginning of a file, it will
  be assigned to the C<"root section">, available at C<$Config-E<gt>{_}>.
  
  Lines starting with C<'#'> or C<';'> are considered comments and ignored,
  as are blank lines.
  
  When writing back to the config file, all comments, custom whitespace,
  and the ordering of your config file elements is discarded. If you need
  to keep the human elements of a config when writing back, upgrade to
  something better, this module is not for you.
  
  =head1 METHODS
  
  =head2 errstr()
  
  Returns a string representing the most recent error, or the empty string.
  
  You can also retrieve the error message from the C<$Config::Tiny::errstr> variable.
  
  =head2 new()
  
  The constructor C<new> creates and returns an empty C<Config::Tiny> object.
  
  =head2 read($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<read> constructor reads a config file, $filename, and returns a new
  C<Config::Tiny> object containing the properties in the file.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '<' or '<:'.
  
  Returns the object on success, or C<undef> on error.
  
  When C<read> fails, C<Config::Tiny> sets an error message internally
  you can recover via C<Config::Tiny-E<gt>errstr>. Although in B<some>
  cases a failed C<read> will also set the operating system error
  variable C<$!>, not all errors do and you should not rely on using
  the C<$!> variable.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 read_string($string)
  
  The C<read_string> method takes as argument the contents of a config file
  as a string and returns the C<Config::Tiny> object for it.
  
  =head2 write($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<write> method generates the file content for the properties, and
  writes it to disk to the filename specified.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '>' or '>:'.
  
  Returns true on success or C<undef> on error.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 write_string()
  
  Generates the file content for the object and returns it as a string.
  
  =head1 FAQ
  
  =head2 Why can't I put comments at the ends of lines?
  
  Because a line like:
  
  	key=value # A comment
  
  Sets key to 'value # A comment' :-(.
  
  This conforms to the syntax discussed in L</CONFIGURATION FILE SYNTAX>.
  
  =head2 Why can't I omit the '=' signs?
  
  E.g.:
  
  	[Things]
  	my =
  	list =
  	of =
  	things =
  
  Instead of:
  
  	[Things]
  	my
  	list
  	of
  	things
  
  Because the use of '=' signs is a type of mandatory documentation. It indicates that that section contains 4 items,
  and not 1 odd item split over 4 lines.
  
  =head2 Why do I have to assign the result of a method call to a variable?
  
  This question comes from RT#85386.
  
  Yes, the syntax may seem odd, but you don't have to call both new() and read_string().
  
  Try:
  
  	perl -MData::Dumper -MConfig::Tiny -E 'my $c=Config::Tiny->read_string("one=s"); say Dumper $c'
  
  Or:
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  Or even, a bit ridiculously:
  
  	my($value) = ${Config::Tiny -> read_string('alpha=bet')}{_}{alpha}; # $value is 'bet'.
  
  =head1 CAVEATS
  
  =head2 Unsupported Section Headers
  
  Some edge cases in section headers are not supported, and additionally may not
  be detected when writing the config file.
  
  Specifically, section headers with leading whitespace, trailing whitespace,
  or newlines anywhere in the section header, will not be written correctly
  to the file and may cause file corruption.
  
  =head2 Setting an option more than once
  
  C<Config::Tiny> will only recognize the first time an option is set in a
  config file. Any further attempts to set the same option later in the config
  file are ignored.
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Config-Tiny>
  
  For other issues, or commercial enhancement or support, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Maintanence from V 2.15: Ron Savage L<http://savage.net.au/>.
  
  =head1 ACKNOWLEGEMENTS
  
  Thanks to Sherzod Ruzmetov E<lt>sherzodr@cpan.orgE<gt> for
  L<Config::Simple>, which inspired this module by being not quite
  "simple" enough for me :).
  
  =head1 SEE ALSO
  
  See, amongst many: L<Config::Simple> and L<Config::General>.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 COPYRIGHT
  
  Copyright 2002 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
CONFIG_TINY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use Fcntl ':flock';
use Getopt::Long;
use App::rmachine;

open my $lock, '<', __FILE__ or die "Can't lock myself\n";
flock $lock, LOCK_EX|LOCK_NB or do { warn "Already running\n"; exit 255 };

my $test = 0;
my $force = 0;
my $quiet = 0;
my $config_file = '';
my $log_file = '';
my $version = '';
GetOptions(
    'test' => \$test,
    'force' => \$force,
    'quiet' => \$quiet,
    'config=s' => \$config_file,
    'log=s' => \$log_file,
    'version' => \$version,
) or die("Error in command line arguments\n");

if ($version) {
    print 'rmachine: ' . $App::rmachine::VERSION, "\n";
    exit 0;
}

App::rmachine->new(config_file => $config_file, log_file => $log_file, quiet => $quiet, test => $test, force => $force)->run(@ARGV);
